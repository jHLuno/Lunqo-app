<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'none';">
  <title>Реклама в такси</title>
  <!-- Font Preloading for Performance -->
  <link rel="preload" href="/fonts/SF-Pro-Display-Regular.otf" as="font" type="font/otf" crossorigin>
  <link rel="preload" href="/fonts/SF-Pro-Display-Medium.otf" as="font" type="font/otf" crossorigin>
  <link rel="preload" href="/fonts/SF-Pro-Display-Bold.otf" as="font" type="font/otf" crossorigin>
  <style>
    @font-face {
      font-family: 'SF Pro Display';
      src: url('/fonts/SF-Pro-Display-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
      font-display: block;
    }
    
    @font-face {
      font-family: 'SF Pro Display';
      src: url('/fonts/SF-Pro-Display-Medium.otf') format('opentype');
      font-weight: 500;
      font-style: normal;
      font-display: block;
    }
    
    @font-face {
      font-family: 'SF Pro Display';
      src: url('/fonts/SF-Pro-Display-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
      font-display: block;
    }
    
    * {
      box-sizing: border-box;
    }
    
    html, body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #050505 0%, #0a0a0a 25%, #0d1117 50%, #161b22 75%, #1a1a2e 100%);
      height: 100%;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* Background Effects */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 25% 25%, rgba(24, 160, 251, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(89, 255, 112, 0.05) 0%, transparent 50%);
      background-size: 100px 100px, 150px 150px;
      opacity: 0.3;
      z-index: -1;
    }
    
    video {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      position: relative;
      z-index: 1;
    }
    
    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #050505 0%, #0a0a0a 25%, #0d1117 50%, #161b22 75%, #1a1a2e 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      transition: opacity 0.5s ease;
    }
    
    .loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-logo {
      width: 120px;
      height: 120px;
      margin-bottom: 32px;
      filter: drop-shadow(0 4px 12px rgba(24, 160, 251, 0.3));
      animation: pulse 2s ease-in-out infinite;
    }
    
    .loading-text {
      color: #ffffff;
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 24px;
      background: linear-gradient(135deg, #18A0FB, #59FF70);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(24, 160, 251, 0.3);
      border-top: 3px solid #18A0FB;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .error-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #050505 0%, #0a0a0a 25%, #0d1117 50%, #161b22 75%, #1a1a2e 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    
    .error-screen.show {
      display: flex;
    }
    
    .error-icon {
      width: 80px;
      height: 80px;
      margin-bottom: 24px;
      color: #FF7A45;
      filter: drop-shadow(0 4px 12px rgba(255, 122, 69, 0.3));
    }
    
    .error-text {
      color: #ffffff;
      font-size: 1.1rem;
      font-weight: 500;
      text-align: center;
      max-width: 400px;
      margin-bottom: 16px;
    }
    
    .error-subtext {
      color: #6c757d;
      font-size: 0.9rem;
      text-align: center;
    }
    
    /* Status Indicator */
    .status-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(33, 37, 41, 0.8);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(52, 58, 64, 0.5);
      border-radius: 12px;
      padding: 12px 16px;
      color: #ffffff;
      font-size: 0.8rem;
      font-weight: 500;
      z-index: 5;
      opacity: 0.8;
      transition: opacity 0.3s ease;
    }
    
    .status-indicator:hover {
      opacity: 1;
    }
    
    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #59FF70;
      margin-right: 8px;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Floating Elements */
    .floating-element {
      position: fixed;
      border-radius: 8px;
      opacity: 0.1;
      animation: float 6s ease-in-out infinite;
      z-index: 0;
    }
    
    .floating-element:nth-child(1) {
      top: 20%;
      left: 10%;
      width: 60px;
      height: 40px;
      background: linear-gradient(135deg, rgba(24, 160, 251, 0.2), rgba(89, 255, 112, 0.2));
      border: 1px solid rgba(24, 160, 251, 0.3);
      animation-delay: 0s;
    }
    
    .floating-element:nth-child(2) {
      top: 60%;
      right: 15%;
      width: 40px;
      height: 30px;
      background: linear-gradient(135deg, rgba(89, 255, 112, 0.2), rgba(255, 122, 69, 0.2));
      border: 1px solid rgba(89, 255, 112, 0.3);
      animation-delay: 2s;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }

    /* Touch Blocker Overlay */
    .touch-blocker {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      background: transparent;
      touch-action: none;
      pointer-events: auto;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .touch-blocker.disabled {
      pointer-events: none;
    }

    /* Prevent text selection and context menus */
    * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Hide scrollbars */
    ::-webkit-scrollbar {
      display: none;
    }

    html {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    /* Kiosk mode styles */
    body.kiosk-mode {
      overflow: hidden !important;
      position: fixed !important;
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>

<!-- Loading Screen -->
<div class="loading-screen" id="loadingScreen">
  <img src="/images/Lunqo-white.59026c78beb9c7f20c86.png" alt="Lunqo Logo" class="loading-logo">
  <div class="loading-text">Загрузка рекламы...</div>
  <div class="loading-spinner"></div>
</div>

<!-- Error Screen -->
<div class="error-screen" id="errorScreen">
  <div class="error-icon">⚠️</div>
  <div class="error-text">Нет доступной рекламы</div>
  <div class="error-subtext">Попробуйте позже</div>
</div>

<!-- Status Indicator -->
<div class="status-indicator" id="statusIndicator">
  <span class="status-dot"></span>
  <span id="statusText">Подключение...</span>
</div>

<!-- Touch Blocker -->
<div class="touch-blocker" id="touchBlocker"></div>

<!-- Floating Elements -->
<div class="floating-element"></div>
<div class="floating-element"></div>

<video id="videoPlayer" autoplay muted playsinline></video>

<script>
  // ===== ENVIRONMENT DETECTION =====
  // Browser-compatible environment detection
  const isProduction = window.location.hostname !== 'localhost' && 
                      window.location.hostname !== '127.0.0.1' && 
                      !window.location.hostname.includes('dev') &&
                      !window.location.hostname.includes('test');

  const screenId = new URLSearchParams(window.location.search).get('screenId') || 'TEST';
  const videoEl = document.getElementById('videoPlayer');
  const loadingScreen = document.getElementById('loadingScreen');
  const errorScreen = document.getElementById('errorScreen');
  const statusIndicator = document.getElementById('statusIndicator');
  const statusText = document.getElementById('statusText');
  const touchBlocker = document.getElementById('touchBlocker');
  
  let playlist = [];
  let index = 0;
  let campaignId = '';
  let brandId = '';
  let isKioskMode = true; // Enable kiosk mode by default
  let fullscreenCheckInterval;
  let statusEventSource = null;
  let isScreenOnline = true;
  let offlineMessageDisplayed = false;

  // Show fullscreen prompt for browsers that require user interaction
  function showFullscreenPrompt() {
    // Don't show if already in fullscreen
    const isFullscreen = !!(document.fullscreenElement || 
                           document.webkitFullscreenElement || 
                           document.mozFullScreenElement || 
                           document.msFullscreenElement);
    if (isFullscreen) return;

    // Debug fullscreen support
    const element = document.documentElement;
    console.log('🔍 Fullscreen API Support Check:');
    console.log('  - requestFullscreen:', !!element.requestFullscreen);
    console.log('  - webkitRequestFullscreen:', !!element.webkitRequestFullscreen);
    console.log('  - webkitRequestFullScreen:', !!element.webkitRequestFullScreen);
    console.log('  - mozRequestFullScreen:', !!element.mozRequestFullScreen);
    console.log('  - msRequestFullscreen:', !!element.msRequestFullscreen);
    console.log('  - document.fullscreenEnabled:', !!document.fullscreenEnabled);
    console.log('  - document.webkitFullscreenEnabled:', !!document.webkitFullscreenEnabled);

    // Create fullscreen prompt overlay
    const fullscreenPrompt = document.createElement('div');
    fullscreenPrompt.id = 'fullscreenPrompt';
    fullscreenPrompt.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 99999;
      color: #ffffff;
      font-family: 'SF Pro Display', sans-serif;
      cursor: pointer;
    `;
    
    fullscreenPrompt.innerHTML = `
      <div style="text-align: center; max-width: 600px; padding: 40px;">
        <div style="font-size: 120px; margin-bottom: 30px; opacity: 0.9;">📺</div>
        <h1 style="font-size: 48px; font-weight: 700; margin-bottom: 20px; background: linear-gradient(135deg, #18A0FB, #59FF70); -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: pulse 2s infinite;">
          Запуск полноэкранного режима
        </h1>
        <p style="font-size: 24px; opacity: 0.8; margin-bottom: 40px; line-height: 1.5;">
          Нажмите в любом месте экрана для входа в режим киоска
        </p>
        <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 30px;">
          <div style="width: 15px; height: 15px; background: linear-gradient(135deg, #18A0FB, #59FF70); border-radius: 50%; animation: bounce 1.5s infinite;"></div>
          <div style="width: 15px; height: 15px; background: linear-gradient(135deg, #59FF70, #38f9d7); border-radius: 50%; animation: bounce 1.5s infinite 0.3s;"></div>
          <div style="width: 15px; height: 15px; background: linear-gradient(135deg, #38f9d7, #18A0FB); border-radius: 50%; animation: bounce 1.5s infinite 0.6s;"></div>
        </div>
        <p style="font-size: 16px; opacity: 0.6;">
          <strong>Для администраторов:</strong> Выход из режима киоска заблокирован в целях безопасности
        </p>
        <button id="manualFullscreenBtn" style="
          background: linear-gradient(135deg, #18A0FB, #59FF70);
          color: white;
          border: none;
          padding: 15px 30px;
          border-radius: 10px;
          font-size: 18px;
          font-weight: 600;
          cursor: pointer;
          margin-top: 20px;
          box-shadow: 0 4px 20px rgba(24, 160, 251, 0.3);
        ">🖱️ Нажмите здесь для полноэкранного режима</button>
        <button id="manualFullscreenBtn" style="
          background: linear-gradient(135deg, #18A0FB, #59FF70);
          color: white;
          border: none;
          padding: 15px 30px;
          border-radius: 10px;
          font-size: 18px;
          font-weight: 600;
          cursor: pointer;
          margin-top: 20px;
          box-shadow: 0 4px 20px rgba(24, 160, 251, 0.3);
        ">🖱️ Нажмите здесь для полноэкранного режима</button>
      </div>
      <style>
        @keyframes pulse {
          0%, 100% { opacity: 0.8; transform: scale(1); }
          50% { opacity: 1; transform: scale(1.05); }
        }
        @keyframes bounce {
          0%, 100% { transform: translateY(0); opacity: 0.7; }
          50% { transform: translateY(-10px); opacity: 1; }
        }
      </style>
    `;
    
    // Add click handler to enter fullscreen
    const enterFullscreenOnClick = async (e) => {
      if (!isProduction) console.log('🖱️ Click detected, attempting fullscreen...');
      
      // Prevent event propagation
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      try {
        // Try multiple fullscreen methods synchronously for user-initiated requests
        const element = document.documentElement;
        let fullscreenPromise = null;
        
        if (element.requestFullscreen) {
          fullscreenPromise = element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
          fullscreenPromise = element.webkitRequestFullscreen();
        } else if (element.webkitRequestFullScreen) {
          fullscreenPromise = element.webkitRequestFullScreen();
        } else if (element.mozRequestFullScreen) {
          fullscreenPromise = element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
          fullscreenPromise = element.msRequestFullscreen();
        }
        
        // Handle the promise if it exists
        if (fullscreenPromise && typeof fullscreenPromise.then === 'function') {
          await fullscreenPromise;
          if (!isProduction) console.log('✅ Fullscreen entered successfully');
        }
        
        // Also call the regular enterFullscreen as backup
        enterFullscreen();
        
      } catch (error) {
        if (!isProduction) console.error('❌ Fullscreen failed:', error);
        // Try the backup method
        enterFullscreen();
      }
      
      // Remove the prompt after fullscreen attempt
      setTimeout(() => {
        if (fullscreenPrompt && fullscreenPrompt.parentNode) {
          fullscreenPrompt.remove();
          if (!isProduction) console.log('🗑️ Fullscreen prompt removed');
        }
      }, 300);
    };
    
    // Add multiple event listeners for better compatibility
    fullscreenPrompt.addEventListener('click', enterFullscreenOnClick);
    fullscreenPrompt.addEventListener('touchstart', enterFullscreenOnClick);
    fullscreenPrompt.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        enterFullscreenOnClick();
      }
    });
    
    // Add specific handler for the manual button
    const manualBtn = fullscreenPrompt.querySelector('#manualFullscreenBtn');
    if (manualBtn) {
      manualBtn.addEventListener('click', async (e) => {
        console.log('🔘 Manual button clicked - attempting fullscreen...'); // Always log this
        e.preventDefault();
        e.stopPropagation();
        
        try {
          const element = document.documentElement;
          
          if (element.requestFullscreen) {
            await element.requestFullscreen();
            console.log('✅ Manual button - requestFullscreen succeeded');
          } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
            console.log('✅ Manual button - webkitRequestFullscreen called');
          } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
            console.log('✅ Manual button - mozRequestFullScreen called');
          } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
            console.log('✅ Manual button - msRequestFullscreen called');
          } else {
            console.log('❌ No fullscreen API available');
          }
        } catch (error) {
          console.error('❌ Manual button fullscreen error:', error);
        }
        
        setTimeout(() => {
          if (fullscreenPrompt && fullscreenPrompt.parentNode) {
            fullscreenPrompt.remove();
          }
        }, 500);
      });
    }
    
    document.body.appendChild(fullscreenPrompt);
    
    // Also add document-level click handler as backup
    const documentClickHandler = async (e) => {
      if (!isProduction) console.log('📄 Document click detected, attempting fullscreen...');
      
      try {
        // Try direct fullscreen API call for user-initiated event
        const element = document.documentElement;
        let fullscreenPromise = null;
        
        if (element.requestFullscreen) {
          fullscreenPromise = element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
          fullscreenPromise = element.webkitRequestFullscreen();
        } else if (element.webkitRequestFullScreen) {
          fullscreenPromise = element.webkitRequestFullScreen();
        } else if (element.mozRequestFullScreen) {
          fullscreenPromise = element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
          fullscreenPromise = element.msRequestFullscreen();
        }
        
        if (fullscreenPromise && typeof fullscreenPromise.then === 'function') {
          await fullscreenPromise;
          if (!isProduction) console.log('✅ Document fullscreen entered successfully');
        }
        
        // Backup call
        enterFullscreen();
        
      } catch (error) {
        if (!isProduction) console.error('❌ Document fullscreen failed:', error);
        enterFullscreen();
      }
      
      setTimeout(() => {
        if (fullscreenPrompt && fullscreenPrompt.parentNode) {
          fullscreenPrompt.remove();
          if (!isProduction) console.log('🗑️ Document handler removed prompt');
        }
        document.removeEventListener('click', documentClickHandler);
        document.removeEventListener('touchstart', documentClickHandler);
      }, 300);
    };
    
    document.addEventListener('click', documentClickHandler, { once: true });
    document.addEventListener('touchstart', documentClickHandler, { once: true });
    
    if (!isProduction) console.log('🔒 Fullscreen prompt displayed');
  }

  // ===== SCREEN STATUS MONITORING =====
  
  // Connect to real-time status updates
  function connectToStatusStream() {
    if (statusEventSource) {
      statusEventSource.close();
    }
    
    const statusUrl = `/api/screens/${screenId}/status-stream`;
    statusEventSource = new EventSource(statusUrl);
    
    statusEventSource.onmessage = function(event) {
      try {
        const data = JSON.parse(event.data);
        handleStatusUpdate(data);
      } catch (error) {
        if (!isProduction) console.error('Error parsing status update:', error);
      }
    };
    
    statusEventSource.onerror = function(error) {
      if (!isProduction) console.error('Status stream error:', error);
      // Attempt to reconnect after 5 seconds
      setTimeout(() => {
        if (statusEventSource.readyState === EventSource.CLOSED) {
          connectToStatusStream();
        }
      }, 5000);
    };
    
    if (!isProduction) console.log('Connected to status stream');
  }
  
  // Handle status updates
  function handleStatusUpdate(data) {
    const wasOnline = isScreenOnline;
    isScreenOnline = data.isOnline;
    
    if (!isProduction) {
      console.log(`📡 Status update: ${data.screenId} is ${isScreenOnline ? 'ONLINE' : 'OFFLINE'}`);
    }
    
    if (wasOnline && !isScreenOnline) {
      // Screen was turned off
      showOfflineMessage();
      pausePlayback();
    } else if (!wasOnline && isScreenOnline) {
      // Screen was turned back on
      hideOfflineMessage();
      resumePlayback();
    }
  }
  
  // Show offline message
  function showOfflineMessage() {
    if (offlineMessageDisplayed) return;
    
    // Pause video
    if (videoEl) {
      videoEl.pause();
    }
    
    // Create offline overlay
    const offlineOverlay = document.createElement('div');
    offlineOverlay.id = 'offlineOverlay';
    offlineOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      color: #ffffff;
      font-family: 'SF Pro Display', sans-serif;
    `;
    
    offlineOverlay.innerHTML = `
      <div style="text-align: center; max-width: 600px; padding: 40px;">
        <div style="font-size: 120px; margin-bottom: 30px; opacity: 0.7;">📺</div>
        <h1 style="font-size: 48px; font-weight: 700; margin-bottom: 20px; background: linear-gradient(135deg, #ff6b6b, #ee5a24); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
          Экран отключен
        </h1>
        <p style="font-size: 24px; opacity: 0.8; margin-bottom: 40px; line-height: 1.5;">
          Администратор временно отключил этот экран.<br>
          Ожидайте восстановления...
        </p>
        <div style="display: flex; justify-content: center; align-items: center; gap: 15px;">
          <div style="width: 12px; height: 12px; background: #ff6b6b; border-radius: 50%; animation: pulse 2s infinite;"></div>
          <div style="width: 12px; height: 12px; background: #ffa726; border-radius: 50%; animation: pulse 2s infinite 0.5s;"></div>
          <div style="width: 12px; height: 12px; background: #42a5f5; border-radius: 50%; animation: pulse 2s infinite 1s;"></div>
        </div>
      </div>
      <style>
        @keyframes pulse {
          0%, 100% { opacity: 0.3; transform: scale(0.8); }
          50% { opacity: 1; transform: scale(1.2); }
        }
      </style>
    `;
    
    document.body.appendChild(offlineOverlay);
    offlineMessageDisplayed = true;
    updateStatus('🔴 Экран отключен администратором');
  }
  
  // Hide offline message
  function hideOfflineMessage() {
    const offlineOverlay = document.getElementById('offlineOverlay');
    if (offlineOverlay) {
      offlineOverlay.remove();
    }
    offlineMessageDisplayed = false;
    updateStatus('🟢 Экран подключен');
  }
  
  // Pause playback
  function pausePlayback() {
    if (videoEl) {
      videoEl.pause();
    }
  }
  
  // Resume playback
  function resumePlayback() {
    if (videoEl && playlist.length > 0) {
      videoEl.play().catch(err => {
        if (!isProduction) console.log('Error resuming video:', err);
      });
    }
  }

  // ===== KIOSK MODE & SECURITY FUNCTIONS =====
  
  // Enhanced fullscreen mode enforcement
  function enterFullscreen() {
    if (!isKioskMode) return;
    
    const element = document.documentElement;
    
    // Try multiple methods aggressively
    const methods = [
      () => element.requestFullscreen && element.requestFullscreen().catch(() => {}),
      () => element.webkitRequestFullscreen && element.webkitRequestFullscreen(),
      () => element.webkitRequestFullScreen && element.webkitRequestFullScreen(), // Alternative webkit
      () => element.mozRequestFullScreen && element.mozRequestFullScreen(),
      () => element.msRequestFullscreen && element.msRequestFullscreen()
    ];
    
    // Try all methods
    methods.forEach(method => {
      try {
        method();
      } catch (e) {
        // Ignore errors, try next method
      }
    });
    
    // Additional focus grabbing
    try {
      window.focus();
      document.body.focus();
      element.focus();
    } catch (e) {
      // Ignore focus errors
    }
    
    // Force browser window to front (works in some browsers)
    try {
      if (window.screen && window.screen.width) {
        // Try to make sure we're taking full screen space
        window.moveTo(0, 0);
        window.resizeTo(window.screen.width, window.screen.height);
      }
    } catch (e) {
      // Ignore if not allowed
    }
  }

  // Enhanced fullscreen checking with multiple methods
  function checkFullscreen() {
    const isFullscreen = !!(document.fullscreenElement || 
                           document.webkitFullscreenElement || 
                           document.mozFullScreenElement || 
                           document.msFullscreenElement);
    
    // Additional checks for edge cases
    const windowIsFullscreen = window.innerHeight === screen.height && 
                              window.innerWidth === screen.width;
    
    const documentIsFullscreen = document.documentElement.clientHeight === screen.height &&
                                document.documentElement.clientWidth === screen.width;
    
    // If any check indicates we're not in fullscreen, force it
    if (!isFullscreen && isKioskMode) {
      if (!isProduction) console.log('📺 Not in fullscreen, forcing aggressively...');
      
      // Multiple immediate attempts with increasing delays
      enterFullscreen();
      setTimeout(enterFullscreen, 1);
      setTimeout(enterFullscreen, 5);
      setTimeout(enterFullscreen, 10);
      setTimeout(enterFullscreen, 25);
      setTimeout(enterFullscreen, 50);
      setTimeout(enterFullscreen, 100);
      
      // Also try to grab focus back
      try {
        window.focus();
        document.body.focus();
        document.documentElement.focus();
      } catch (e) {
        // Ignore focus errors
      }
    }
    
    // Extra check for window size even if fullscreen API says we're fullscreen
    if (isKioskMode && (!windowIsFullscreen || !documentIsFullscreen)) {
      if (!isProduction) console.log('📺 Window size mismatch, re-entering fullscreen...');
      setTimeout(enterFullscreen, 1);
      setTimeout(enterFullscreen, 10);
    }
  }

  // Initialize kiosk mode
  function initKioskMode() {
    if (!isKioskMode) return;

    document.body.classList.add('kiosk-mode');
    
    // Try to enter fullscreen immediately (works in some browsers)
    enterFullscreen();
    
    // Try multiple times with different delays for better browser compatibility
    setTimeout(enterFullscreen, 100);
    setTimeout(enterFullscreen, 250);
    setTimeout(enterFullscreen, 500);
    
    // If that doesn't work, show prompt and wait for user interaction
    setTimeout(() => {
      const isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
      
      if (!isFullscreen && !document.getElementById('fullscreenPrompt')) {
        showFullscreenPrompt();
      }
    }, 1000);

    // Check fullscreen every 50ms for even faster response
    fullscreenCheckInterval = setInterval(checkFullscreen, 50);
    
    // Additional aggressive monitoring
    const aggressiveCheckInterval = setInterval(() => {
      if (isKioskMode) {
        const isFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
        if (!isFullscreen) {
          enterFullscreen();
        }
      }
    }, 25);

    // Enhanced keyboard blocking with multiple capture methods
    const handleKeyBlock = (e) => {
      const blockedKeys = [
        'F11', 'F12', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',
        'Tab', 'Alt', 'Meta', 'Control', 'PrintScreen', 'Insert', 'Delete',
        'Home', 'End', 'PageUp', 'PageDown', 'ContextMenu'
      ];
      
      // Block by key code as well for more comprehensive coverage
      const blockedKeyCodes = [
        122, 123, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, // F11, F12, F1-F10
        9, 18, 91, 17, 44, 45, 46, 36, 35, 33, 34, 93, 27 // Tab, Alt, Meta, Ctrl, etc.
      ];
      
      // Immediate blocking for any suspicious key
      if (e.key === 'F11' || e.keyCode === 122 || 
          e.key === 'F12' || e.keyCode === 123 || 
          e.key === 'Escape' || e.keyCode === 27) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        // Aggressive fullscreen re-entry
        for (let i = 0; i < 10; i++) {
          setTimeout(() => enterFullscreen(), i * 5);
        }
        
        if (!isProduction) console.log('🚫 Blocked fullscreen exit key:', e.key);
        return false;
      }
      
      // Block all modifier key combinations
      if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return false;
      }
      
      // Block specific keys by name and code
      if (blockedKeys.includes(e.key) || blockedKeys.includes(e.code) || 
          blockedKeyCodes.includes(e.keyCode) || blockedKeyCodes.includes(e.which)) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return false;
      }
    };
    
    // Add multiple event listeners for maximum coverage
    document.addEventListener('keydown', handleKeyBlock, true);
    document.addEventListener('keyup', handleKeyBlock, true);
    document.addEventListener('keypress', handleKeyBlock, true);
    window.addEventListener('keydown', handleKeyBlock, true);
    window.addEventListener('keyup', handleKeyBlock, true);
    window.addEventListener('keypress', handleKeyBlock, true);

    // Block right-click context menu
    document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      return false;
    });

    // Block text selection
    document.addEventListener('selectstart', (e) => {
      e.preventDefault();
      return false;
    });

    // Block drag and drop
    document.addEventListener('dragstart', (e) => {
      e.preventDefault();
      return false;
    });

    // Monitor mouse movements near screen edges (detect attempts to access browser UI)
    document.addEventListener('mousemove', (e) => {
      if (!isKioskMode) return;
      
      const margin = 5; // pixels from edge
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      // Check if mouse is near top edge (where browser UI might be)
      if (e.clientY <= margin || e.clientX <= margin || 
          e.clientX >= windowWidth - margin || e.clientY >= windowHeight - margin) {
        
        // Force focus back and re-enter fullscreen
        setTimeout(() => {
          window.focus();
          enterFullscreen();
        }, 1);
      }
    });

    // Additional protection against window object manipulation
    const originalAlert = window.alert;
    const originalConfirm = window.confirm;
    const originalPrompt = window.prompt;
    
    // Override dialog functions in kiosk mode
    if (isKioskMode) {
      window.alert = function() { 
        enterFullscreen(); 
        return originalAlert.apply(this, arguments); 
      };
      window.confirm = function() { 
        enterFullscreen(); 
        return originalConfirm.apply(this, arguments); 
      };
      window.prompt = function() { 
        enterFullscreen(); 
        return originalPrompt.apply(this, arguments); 
      };
    }
  }

  // Initialize touch blocker
  function initTouchBlocker() {
    if (!touchBlocker) return;

    // Block all touch events
    const blockEvents = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
    
    blockEvents.forEach(eventType => {
      touchBlocker.addEventListener(eventType, (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!isProduction) {
          console.log('🚫 Touch blocked:', eventType);
        }
        
        return false;
      }, { passive: false, capture: true });
    });

    // Also block mouse events for desktop testing
    const mouseEvents = ['mousedown', 'mouseup', 'mousemove', 'click', 'dblclick'];
    
    mouseEvents.forEach(eventType => {
      touchBlocker.addEventListener(eventType, (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!isProduction) {
          console.log('🚫 Mouse blocked:', eventType);
        }
        
        return false;
      }, { passive: false, capture: true });
    });

    if (!isProduction) {
      console.log('🔒 Touch blocker initialized');
    }
  }

  // Aggressive fullscreen change handlers with immediate re-enforcement
  const handleFullscreenExit = (eventName) => {
    return () => {
      const isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
      
      if (!isProduction) {
        console.log(`📺 ${eventName} - Fullscreen:`, isFullscreen);
      }
      
      // If fullscreen was exited and kiosk mode is on, immediately re-enter with maximum aggression
      if (!isFullscreen && isKioskMode) {
        if (!isProduction) console.log('🚨 Fullscreen exit detected, forcing re-entry!');
        
        // Immediate re-entry with multiple attempts
        for (let i = 0; i < 15; i++) {
          setTimeout(() => enterFullscreen(), i * 2);
        }
        
        // Additional delayed attempts
        setTimeout(enterFullscreen, 50);
        setTimeout(enterFullscreen, 100);
        setTimeout(enterFullscreen, 200);
      }
    };
  };

  // Add handlers for all browser variants
  document.addEventListener('fullscreenchange', handleFullscreenExit('fullscreenchange'));
  document.addEventListener('webkitfullscreenchange', handleFullscreenExit('webkitfullscreenchange'));
  document.addEventListener('mozfullscreenchange', handleFullscreenExit('mozfullscreenchange'));
  document.addEventListener('msfullscreenchange', handleFullscreenExit('msfullscreenchange'));
  
  // Also add to window for extra coverage
  window.addEventListener('fullscreenchange', handleFullscreenExit('window-fullscreenchange'));
  window.addEventListener('webkitfullscreenchange', handleFullscreenExit('window-webkitfullscreenchange'));
  window.addEventListener('mozfullscreenchange', handleFullscreenExit('window-mozfullscreenchange'));
  window.addEventListener('msfullscreenchange', handleFullscreenExit('window-msfullscreenchange'));

  // Enhanced window focus and visibility monitoring
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && isKioskMode) {
      if (!isProduction) console.log('🔒 Tab hidden, will regain focus when visible');
    } else if (!document.hidden && isKioskMode) {
      if (!isProduction) console.log('🔒 Tab visible, forcing fullscreen');
      // Aggressively regain fullscreen when tab becomes visible
      setTimeout(() => {
        window.focus();
        enterFullscreen();
        setTimeout(enterFullscreen, 10);
        setTimeout(enterFullscreen, 50);
      }, 10);
    }
  });

  // Window focus events
  window.addEventListener('focus', () => {
    if (isKioskMode) {
      if (!isProduction) console.log('🔒 Window gained focus, ensuring fullscreen');
      setTimeout(enterFullscreen, 10);
    }
  });

  window.addEventListener('blur', () => {
    if (isKioskMode) {
      if (!isProduction) console.log('🔒 Window lost focus, will regain');
      // Try to regain focus quickly
      setTimeout(() => {
        window.focus();
        enterFullscreen();
      }, 50);
    }
  });

  // Window resize events (catch window manipulation)
  window.addEventListener('resize', () => {
    if (isKioskMode) {
      if (!isProduction) console.log('🔒 Window resized, ensuring fullscreen');
      setTimeout(enterFullscreen, 10);
    }
  });

  // Document focus events
  document.addEventListener('focusin', () => {
    if (isKioskMode) {
      setTimeout(enterFullscreen, 1);
    }
  });

  document.addEventListener('focusout', () => {
    if (isKioskMode) {
      setTimeout(() => {
        document.body.focus();
        enterFullscreen();
      }, 10);
    }
  });

  // Update status indicator
  function updateStatus(text) {
    statusText.textContent = text;
    if (!isProduction) {
      console.log('📊 Status:', text);
    }
  }

  // Show error screen
  function showError() {
    loadingScreen.classList.add('hidden');
    errorScreen.classList.add('show');
    updateStatus('Ошибка загрузки');
  }

  // Hide loading screen
  function hideLoading() {
    loadingScreen.classList.add('hidden');
    updateStatus('Воспроизведение');
  }

  // Получаем плейлист с сервера
  async function fetchPlaylist() {
    try {
      updateStatus('Загрузка плейлиста...');
      const res = await fetch(`/api/screens/${screenId}/playlist`);
      const data = await res.json();

      // Check if screen is offline (503 status)
      if (res.status === 503) {
        isScreenOnline = false;
        showOfflineMessage();
        return;
      }

      if (data && data.videos && data.videos.length > 0) {
        playlist = data.videos;
        campaignId = data.campaignId || '';
        brandId = data.brandId || '';
        isScreenOnline = data.isOnline !== false;
        index = 0;
        updateStatus('Плейлист загружен');
        
        if (isScreenOnline) {
          playVideo();
        } else {
          showOfflineMessage();
        }
      } else {
        if (!isProduction) {
          console.log("Нет видео в плейлисте");
        }
        showError();
      }
    } catch (err) {
      console.error('Ошибка получения плейлиста:', err);
      showError();
    }
  }

  // Воспроизводим видео
  function playVideo() {
    if (playlist.length === 0) return;
    
    // Don't play if screen is offline
    if (!isScreenOnline) {
      showOfflineMessage();
      return;
    }

    videoEl.src = playlist[index];
    videoEl.load();
    
    videoEl.onloadeddata = () => {
      hideLoading();
      videoEl.play();
      updateStatus(`Видео ${index + 1}/${playlist.length}`);
    };

    if (!isProduction) {
      console.log(`▶️ Воспроизведение видео: ${playlist[index]}`);
    }

    index = (index + 1) % playlist.length;
  }

  videoEl.addEventListener('ended', playVideo);

  // Отправка статистики каждые 30 секунд
  setInterval(() => {
    if (!playlist.length || !campaignId || !brandId) {
      if (!isProduction) {
        console.log('❌ Не могу отправить статистику: отсутствуют данные', { playlist: playlist.length, campaignId, brandId });
      }
      return;
    }

    if (!isProduction) {
      console.log('📊 Отправляю статистику:', { screenId, campaignId, brandId, event: 'impression' });
    }

    fetch('/api/stats', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        screenId,
        campaignId,
        brandId,
        event: 'impression'
      })
    }).then(res => {
      if (!res.ok) {
        return res.text().then(text => {
          throw new Error(`HTTP ${res.status}: ${text}`);
        });
      }
      return res.json();
    }).then(data => {
      if (!isProduction) {
        console.log('✅ Импрессия отправлена:', data);
      }
    }).catch(err => {
      console.error('❌ Ошибка отправки статистики:', err);
    });
  }, 30000);

  // ===== ADMIN UNLOCK SEQUENCE =====
  let unlockSequence = [];
  const unlockCode = ['KeyK', 'KeyI', 'KeyO', 'KeyS', 'KeyK']; // K-I-O-S-K sequence
  
  function handleUnlockSequence(e) {
    if (!isKioskMode) return;
    
    unlockSequence.push(e.code);
    
    // Keep only last 5 keys
    if (unlockSequence.length > unlockCode.length) {
      unlockSequence.shift();
    }
    
    // Check if sequence matches
    if (unlockSequence.length === unlockCode.length && 
        unlockSequence.every((key, index) => key === unlockCode[index])) {
      
      disableKioskMode();
      unlockSequence = [];
      
      if (!isProduction) {
        console.log('🔓 Kiosk mode disabled by admin sequence');
      }
    }
  }
  
  // Disable kiosk mode (for admin access)
  function disableKioskMode() {
    isKioskMode = false;
    
    if (fullscreenCheckInterval) {
      clearInterval(fullscreenCheckInterval);
    }
    
    document.body.classList.remove('kiosk-mode');
    touchBlocker.classList.add('disabled');
    
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
    
    updateStatus('Kiosk mode отключен');
    
    // Show unlock notification
    setTimeout(() => {
      alert('🔓 Kiosk mode disabled.\nRefresh page to re-enable.');
    }, 500);
  }
  
  // Add unlock sequence listener
  document.addEventListener('keydown', handleUnlockSequence);

  // ===== ADDITIONAL SECURITY MEASURES =====
  
  // Prevent iframe embedding at runtime
  if (window.top !== window.self) {
    window.top.location = window.self.location;
  }

  // Add multiple F11 blockers at different event phases
  document.addEventListener('keydown', (e) => {
    if (e.key === 'F11' || e.keyCode === 122) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      enterFullscreen();
      return false;
    }
  }, true);

  document.addEventListener('keypress', (e) => {
    if (e.key === 'F11' || e.keyCode === 122) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      enterFullscreen();
      return false;
    }
  }, true);

  document.addEventListener('keyup', (e) => {
    if (e.key === 'F11' || e.keyCode === 122) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      enterFullscreen();
      setTimeout(enterFullscreen, 1);
      return false;
    }
  }, true);
  
  // Block common developer tools shortcuts
  document.addEventListener('keydown', (e) => {
    // Block F12 (DevTools)
    if (e.keyCode === 123) {
      e.preventDefault();
      return false;
    }
    
    // Block Ctrl+Shift+I (DevTools)
    if (e.ctrlKey && e.shiftKey && e.keyCode === 73) {
      e.preventDefault();
      return false;
    }
    
    // Block Ctrl+Shift+J (Console)
    if (e.ctrlKey && e.shiftKey && e.keyCode === 74) {
      e.preventDefault();
      return false;
    }
    
    // Block Ctrl+U (View Source)
    if (e.ctrlKey && e.keyCode === 85) {
      e.preventDefault();
      return false;
    }
    
    // Block Ctrl+Shift+C (Element Inspector)
    if (e.ctrlKey && e.shiftKey && e.keyCode === 67) {
      e.preventDefault();
      return false;
    }
  });
  
  // Detect developer tools (basic detection)
  setInterval(() => {
    if (isKioskMode) {
      const threshold = 160;
      if (window.outerHeight - window.innerHeight > threshold || 
          window.outerWidth - window.innerWidth > threshold) {
        if (!isProduction) {
          console.log('🔒 Potential developer tools detected');
        }
        // Could add additional actions here like reloading or alerting
      }
    }
  }, 5000);

  // Prevent page zoom
  document.addEventListener('wheel', (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      return false;
    }
  }, { passive: false });

  // Block pinch-to-zoom on mobile
  document.addEventListener('touchmove', (e) => {
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });

  // ===== INITIALIZATION =====
  
  // Add global click-to-fullscreen handler for immediate response
  function setupGlobalFullscreenTriggers() {
    let globalHandlerUsed = false;
    
    const globalFullscreenHandler = async (e) => {
      if (globalHandlerUsed) return; // Prevent multiple triggers
      globalHandlerUsed = true;
      
      if (!isProduction) console.log('🌍 Global click handler triggered');
      
      try {
        const element = document.documentElement;
        let result = false;
        
        // Try all fullscreen methods
        if (element.requestFullscreen) {
          await element.requestFullscreen();
          result = true;
        } else if (element.webkitRequestFullscreen) {
          element.webkitRequestFullscreen();
          result = true;
        } else if (element.webkitRequestFullScreen) {
          element.webkitRequestFullScreen();
          result = true;
        } else if (element.mozRequestFullScreen) {
          element.mozRequestFullScreen();
          result = true;
        } else if (element.msRequestFullscreen) {
          element.msRequestFullscreen();
          result = true;
        }
        
        if (result && !isProduction) {
          console.log('✅ Global handler successfully triggered fullscreen');
        }
        
        // Remove any visible prompts
        const prompt = document.getElementById('fullscreenPrompt');
        if (prompt) {
          prompt.remove();
        }
        
      } catch (error) {
        if (!isProduction) console.error('❌ Global fullscreen handler failed:', error);
      }
      
      // Remove the global handlers after first use
      document.removeEventListener('click', globalFullscreenHandler);
      document.removeEventListener('touchstart', globalFullscreenHandler);
    };
    
    // Add global handlers
    document.addEventListener('click', globalFullscreenHandler, { once: true, capture: true });
    document.addEventListener('touchstart', globalFullscreenHandler, { once: true, capture: true });
    
    if (!isProduction) console.log('🌍 Global fullscreen triggers setup');
  }
  
  // Wait for DOM to be fully ready, then initialize
  function initializeApp() {
    // Setup global fullscreen triggers first
    setupGlobalFullscreenTriggers();
    
    // Initialize security features
    initKioskMode();
    initTouchBlocker();
    
    // Connect to real-time status updates
    connectToStatusStream();
    
    // Initialize playlist
    fetchPlaylist();
    
    // Keep trying to enter fullscreen every 2 seconds if not in fullscreen
    const fullscreenRetryInterval = setInterval(() => {
      const isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
      
      if (!isFullscreen && isKioskMode) {
        // Try to enter fullscreen automatically
        enterFullscreen();
        
        // If still not fullscreen after 1 second, show prompt
        setTimeout(() => {
          const stillNotFullscreen = !!(document.fullscreenElement || 
                                        document.webkitFullscreenElement || 
                                        document.mozFullScreenElement || 
                                        document.msFullscreenElement);
          
          if (!stillNotFullscreen && !document.getElementById('fullscreenPrompt')) {
            showFullscreenPrompt();
          }
        }, 1000);
      } else if (isFullscreen) {
        // We're in fullscreen, remove any prompt that might be showing
        const prompt = document.getElementById('fullscreenPrompt');
        if (prompt) {
          prompt.remove();
        }
      }
    }, 2000);
  }
  
  // Initialize immediately if DOM is already ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
  } else {
    initializeApp();
  }
  
  // Also try on window load as backup
  window.addEventListener('load', () => {
    setTimeout(() => {
      const isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
      
      if (!isFullscreen && isKioskMode) {
        enterFullscreen();
        setTimeout(() => {
          const stillNotFullscreen = !!(document.fullscreenElement || 
                                        document.webkitFullscreenElement || 
                                        document.mozFullScreenElement || 
                                        document.msFullscreenElement);
          
          if (!stillNotFullscreen && !document.getElementById('fullscreenPrompt')) {
            showFullscreenPrompt();
          }
        }, 500);
      }
    }, 100);
  });
  
  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (statusEventSource) {
      statusEventSource.close();
    }
  });
</script>

</body>
</html>